// Usar la referencia compartida al API de VS Code
const vscode = window.vscodeApi || (window.vscodeApi = acquireVsCodeApi());

// Variables globales con nombres claros
let allTabs = [];
let tabContainer;

// Asegurar que los objetos globales están disponibles
window.tabsManager = window.tabsManager || {};
window.tabInteractions = window.tabInteractions || {};
window.sidetabsEventManager = window.sidetabsEventManager || {};

/// TabManager: gestión de pestañas
const TabManager = {
	initialize() {
		tabContainer = document.querySelector('#tabs-container');
		if (!tabContainer) {
			console.error('[LoverTab | sidetabs.js] No se encontró el contenedor de pestañas');
			return false;
		}
		this.rebuildTabCache();
		return true;
	},

	//* ✔ Reconstruye la caché de pestañas para acceso rápido
	//     Esto se llama al cargar el webview o cuando se actualiza el contenido de las
	rebuildTabCache() {
		allTabs = Array.from(document.querySelectorAll('.tab'));
		console.log(`[LoverTab | sidetabs.js] Cache de pestañas reconstruido. ${allTabs.length} pestañas encontradas.`);
	},

	//* ✔ Actualiza visualmente la pestaña activa
	updateActiveTab(activeTabId) {
		if (!activeTabId) return;
		allTabs.forEach(tab => tab.classList.remove('active'));
		const activeTab = document.querySelector(`.tab[data-unique-id="${activeTabId}"]`);
		if (activeTab) {
			activeTab.classList.add('active');
			activeTab.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
		}
	},

	//* Determina el nivel de alerta más crítico (error > warning > info)
	getDiagnosisLevel(diagnosis) {
		if (!diagnosis) return undefined;
		if (diagnosis.errors > 0) return 'error';
		if (diagnosis.warnings > 0) return 'warning';
		if (diagnosis.infos > 0) return 'info';
		return undefined;
	},

	//* Actualiza solo la parte de diagnóstico compacto de una pestaña (basado en TabTemplates.ts)
	renderDiagnosis(diagnosis) {
		if (!diagnosis || (diagnosis.errors === 0 && diagnosis.warnings === 0 && diagnosis.infos === 0)) {
			return ''; // No hay diagnósticos para mostrar
		}

		// Implementación de getInlineDiagnosisCount, similar a TabTemplates.ts
		const getInlineDiagnosisCount = (count, type) => {
			if (count <= 0) return '';
			const title = type === 'error' ? 'errores' : type === 'warning' ? 'advertencias' : 'info';
			return `<span class="diagnosis-count ${type}" title="${count} ${title}">${count}</span>`;
		};

		// Genera las partes de diagnóstico
		const parts = [];
		if (diagnosis.errors > 0) parts.push(getInlineDiagnosisCount(diagnosis.errors, 'error'));
		if (diagnosis.warnings > 0) parts.push(getInlineDiagnosisCount(diagnosis.warnings, 'warning'));
		if (diagnosis.infos > 0) parts.push(getInlineDiagnosisCount(diagnosis.infos, 'info'));

		// Combina las partes con el separador
		if (parts.length > 0) {
			return parts.join('<span class="diagnosis-sep">|</span>');
		}
		return '';
	},

	updateCompactDiagnosis(tab, diagnosis) {
		if (!diagnosis) {
			console.log('[LoverTab | sidetabs.js] No hay diagnóstico proporcionado para actualizar');
			return;
		}

		// Determinar si hay algún diagnóstico a mostrar
		const hasDiagnosis = diagnosis.errors > 0 || diagnosis.warnings > 0 || diagnosis.infos > 0;

		console.log('[LoverTab | sidetabs.js] Actualizando diagnóstico compacto:', diagnosis);

		// Encuentra el elemento del nombre de archivo
		const filename = tab.querySelector('.tab-filename');
		if (!filename) {
			console.log('[LoverTab | sidetabs.js] No se encontró el elemento filename en la pestaña');
			return;
		}

		// Determinar el nivel de diagnóstico para colorear el nombre del archivo
		const diagnosisLevel = this.getDiagnosisLevel(diagnosis);

		// Aplicar clase según el nivel de diagnóstico al filename
		// Primero eliminar todas las posibles clases de diagnóstico
		filename.classList.remove('error', 'warning', 'info');

		// Añadir la clase correspondiente al nivel más crítico si hay diagnósticos
		if (diagnosisLevel) {
			filename.classList.add(diagnosisLevel);
			console.log(`[LoverTab | sidetabs.js] Aplicando clase ${diagnosisLevel} al filename`);
		}

		// Encuentra o crea el contenedor de diagnóstico compacto
		let diagnosisContainer = tab.querySelector('.diagnosis-compact');

		if (!diagnosisContainer && hasDiagnosis) {
			console.log('[LoverTab | sidetabs.js] Creando nuevo contenedor diagnosis-compact');
			// Si no existe el contenedor y hay diagnósticos, crear uno nuevo después del nombre
			diagnosisContainer = document.createElement('span');
			diagnosisContainer.className = 'diagnosis-compact';
			filename.appendChild(document.createTextNode(' '));
			filename.appendChild(diagnosisContainer);
		}

		// Si tenemos un contenedor de diagnóstico, actualizarlo
		if (diagnosisContainer) {
			// Usar el mismo enfoque que renderDiagnosis en TabTemplates.ts
			const diagnosisHTML = this.renderDiagnosis(diagnosis);

			// Actualizar el contenido del diagnóstico
			if (diagnosisHTML) {
				diagnosisContainer.innerHTML = diagnosisHTML;
				diagnosisContainer.style.display = 'inline';
			} else {
				// Si no hay diagnósticos, ocultar el contenedor
				diagnosisContainer.style.display = 'none';
				diagnosisContainer.innerHTML = '';
			}
		}
	},

	//* Actualiza los diagnósticos para todas las pestañas
	updateDiagnosis(diagnosticUpdates) {
		if (!diagnosticUpdates || !Array.isArray(diagnosticUpdates)) {
			console.log('[LoverTab | sidetabs.js] No hay actualizaciones de diagnósticos válidas');
			return;
		}

		console.log(`[LoverTab | sidetabs.js] Actualizando diagnósticos para ${diagnosticUpdates.length} pestañas`);

		// Crear mapa de diagnósticos por ID para actualización eficiente
		const diagnosisMap = new Map();
		diagnosticUpdates.forEach(update => {
			if (update.uniqueId && update.diagnosis) {
				diagnosisMap.set(update.uniqueId, update.diagnosis);
			}
		});

		// Actualizar cada pestaña con sus diagnósticos correspondientes
		allTabs.forEach(tab => {
			const tabId = tab.dataset.uniqueId;
			if (!tabId) return;

			// Si tenemos un diagnóstico actualizado para esta pestaña, aplicarlo
			if (diagnosisMap.has(tabId)) {
				this.updateCompactDiagnosis(tab, diagnosisMap.get(tabId));
			}
			// Si la pestaña no está en la lista de actualizaciones pero tiene alguna clase de diagnóstico,
			// limpiar las clases (podría ser un archivo que ya no tiene problemas)
			else {
				const filename = tab.querySelector('.tab-filename');
				if (filename && (filename.classList.contains('error') ||
					filename.classList.contains('warning') ||
					filename.classList.contains('info'))) {

					console.log(`[LoverTab | sidetabs.js] Limpiando clases de diagnóstico para ${tabId}`);
					filename.classList.remove('error', 'warning', 'info');

					// También limpiar el contenedor de diagnóstico si existe
					const diagnosisContainer = tab.querySelector('.diagnosis-compact');
					if (diagnosisContainer) {
						diagnosisContainer.style.display = 'none';
						diagnosisContainer.innerHTML = '';
					}
				}
			}
		});
	}
};

/// EventHandler: gestión de eventos y mensajes
const EventHandler = {
	initialize() {
		this.setupMessageListener();
		this.setupBasicEventListeners();
		return true;
	},

	setupMessageListener() {
		window.addEventListener('message', event => {
			const message = event.data;
			const command = message.type || message.command;
			console.log(`[LoverTab | sidetabs.js] Mensaje recibido:`, command, message);
			const handler = this.messageHandlers[command];
			if (handler) {
				handler(message);
			} else {
				console.log(`[LoverTab | sidetabs.js] Mensaje no manejado: ${command}`, message);
			}
		});
	},

	setupBasicEventListeners() {
		if (!tabContainer) return;
		tabContainer.addEventListener('click', this.handleTabClick);
		tabContainer.addEventListener('contextmenu', this.handleContextMenu);
		this.setupDragDrop();
	},

	setupDragDrop() {
		// Si no hay contenedor de pestañas, salimos
		if (!tabContainer) return;

		// Variables para seguimiento de arrastre
		let isDragging = false;
		let draggedTab = null;
		let originalOrder = [];
		let startX, startY;

		// Guardar el orden original de las pestañas
		function saveOriginalOrder() {
			originalOrder = Array.from(tabContainer.querySelectorAll('.tab')).map(tab => tab.dataset.uniqueId);
			console.log('[LoverTab | sidetabs.js] Orden original guardado:', originalOrder);
		}

		// Iniciar arrastre
		function handleDragStart(e) {
			draggedTab = e.target.closest('.tab');
			if (!draggedTab) return;

			// Prevenir comportamiento predeterminado
			e.preventDefault();

			// Guardar posición inicial
			startX = e.clientX;
			startY = e.clientY;

			// Marcar como arrastrando
			isDragging = true;

			// Guardar orden original
			saveOriginalOrder();

			// Aplicar clases: la arrastrada como 'dragging', las demás como 'static'
			draggedTab.classList.add('dragging');
			allTabs.forEach(tab => {
				if (tab !== draggedTab) {
					tab.classList.add('static');
				}
			});

			// Agregar listener para movimiento y soltar
			document.addEventListener('mousemove', handleDragMove);
			document.addEventListener('mouseup', handleDragEnd);

			console.log('[LoverTab | sidetabs.js] Iniciado arrastre de pestaña:', draggedTab.dataset.uniqueId);
		}

		// Manejar el movimiento durante el arrastre
		function handleDragMove(e) {
			if (!isDragging || !draggedTab) return;

			// Recorrer todas las pestañas estáticas
			const staticTabs = Array.from(tabContainer.querySelectorAll('.tab.static'));
			
			// Verificar si el cursor está cerca del punto medio de alguna pestaña
			for (const tab of staticTabs) {
				const tabRect = tab.getBoundingClientRect();
				const tabMiddle = tabRect.left + tabRect.width / 2;
				
				// Si el cursor cruza el punto medio horizontal de una pestaña
				if (e.clientX > tabRect.left && e.clientX < tabRect.right && 
					Math.abs(e.clientX - tabMiddle) < tabRect.width / 2) {
					
					// Determinar si debe ir antes o después basado en la posición
					if (e.clientX < tabMiddle) {
						tabContainer.insertBefore(draggedTab, tab);
					} else {
						const nextTab = tab.nextElementSibling;
						if (nextTab) {
							tabContainer.insertBefore(draggedTab, nextTab);
						} else {
							tabContainer.appendChild(draggedTab);
						}
					}
					break;
				}
			}
		}

		// Finalizar arrastre
		function handleDragEnd(e) {
			if (!isDragging || !draggedTab) return;
			
			// Eliminar clases de arrastre
			draggedTab.classList.remove('dragging');
			allTabs.forEach(tab => tab.classList.remove('static'));
			
			// Obtener nuevo orden
			const newOrder = Array.from(tabContainer.querySelectorAll('.tab')).map(tab => tab.dataset.uniqueId);
			console.log('[LoverTab | sidetabs.js] Nuevo orden:', newOrder);
			
			// Enviar mensaje al backend con el nuevo orden
			vscode.postMessage({
				command: 'reorderTabs',
				order: newOrder,
				originalOrder: originalOrder
			});
			
			// Limpiar estado de arrastre
			isDragging = false;
			draggedTab = null;
			
			// Eliminar event listeners
			document.removeEventListener('mousemove', handleDragMove);
			document.removeEventListener('mouseup', handleDragEnd);
		}

		// Agregar event listener para iniciar arrastre
		tabContainer.querySelectorAll('.tab').forEach(tab => {
			tab.addEventListener('mousedown', handleDragStart);
		});
	},

	handleTabClick(e) {
		const tab = e.target.closest('.tab');
		if (!tab) return;
		const closeBtn = e.target.closest('.tab-close-button');
		if (closeBtn) {
			vscode.postMessage({
				command: 'tabClosed',
				uniqueId: tab.dataset.uniqueId
			});
			return;
		}
		vscode.postMessage({
			command: 'tabClicked',
			uniqueId: tab.dataset.uniqueId
		});
	},

	handleContextMenu(e) {
		const tab = e.target.closest('.tab');
		if (!tab) return;
		e.preventDefault();
		vscode.postMessage({
			command: 'showContextMenu',
			uniqueId: tab.dataset.uniqueId,
			x: e.clientX,
			y: e.clientY
		});
	},

	setupDragDrop() {
		// Si no hay contenedor de pestañas, salimos
		if (!tabContainer) return;

		// Variables para seguimiento de arrastre
		let isDragging = false;
		let draggedTab = null;
		let originalOrder = [];
		let startX, startY;

		// Guardar el orden original de las pestañas
		function saveOriginalOrder() {
			originalOrder = Array.from(tabContainer.querySelectorAll('.tab')).map(tab => tab.dataset.uniqueId);
			console.log('[LoverTab | sidetabs.js] Orden original guardado:', originalOrder);
		}

		// Iniciar arrastre
		function handleDragStart(e) {
			draggedTab = e.target.closest('.tab');
			if (!draggedTab) return;

			// Prevenir comportamiento predeterminado
			e.preventDefault();

			// Guardar posición inicial
			startX = e.clientX;
			startY = e.clientY;

			// Marcar como arrastrando
			isDragging = true;

			// Guardar orden original
			saveOriginalOrder();

			// Aplicar clases: la arrastrada como 'dragging', las demás como 'static'
			draggedTab.classList.add('dragging');
			allTabs.forEach(tab => {
				if (tab !== draggedTab) {
					tab.classList.add('static');
				}
			});

			// Agregar listener para movimiento y soltar
			document.addEventListener('mousemove', handleDragMove);
			document.addEventListener('mouseup', handleDragEnd);

			console.log('[LoverTab | sidetabs.js] Iniciado arrastre de pestaña:', draggedTab.dataset.uniqueId);
		}

		// Manejar el movimiento durante el arrastre
		function handleDragMove(e) {
			if (!isDragging || !draggedTab) return;

			// Recorrer todas las pestañas estáticas
			const staticTabs = Array.from(tabContainer.querySelectorAll('.tab.static'));
			
			// Verificar si el cursor está cerca del punto medio de alguna pestaña
			for (const tab of staticTabs) {
				const tabRect = tab.getBoundingClientRect();
				const tabMiddle = tabRect.left + tabRect.width / 2;
				
				// Si el cursor cruza el punto medio horizontal de una pestaña
				if (e.clientX > tabRect.left && e.clientX < tabRect.right && 
					Math.abs(e.clientX - tabMiddle) < tabRect.width / 2) {
					
					// Determinar si debe ir antes o después basado en la posición
					if (e.clientX < tabMiddle) {
						tabContainer.insertBefore(draggedTab, tab);
					} else {
						const nextTab = tab.nextElementSibling;
						if (nextTab) {
							tabContainer.insertBefore(draggedTab, nextTab);
						} else {
							tabContainer.appendChild(draggedTab);
						}
					}
					break;
				}
			}
		}

		// Finalizar arrastre
		function handleDragEnd(e) {
			if (!isDragging || !draggedTab) return;
			
			// Eliminar clases de arrastre
			draggedTab.classList.remove('dragging');
			allTabs.forEach(tab => tab.classList.remove('static'));
			
			// Obtener nuevo orden
			const newOrder = Array.from(tabContainer.querySelectorAll('.tab')).map(tab => tab.dataset.uniqueId);
			console.log('[LoverTab | sidetabs.js] Nuevo orden:', newOrder);
			
			// Enviar mensaje al backend con el nuevo orden
			vscode.postMessage({
				command: 'reorderTabs',
				order: newOrder,
				originalOrder: originalOrder
			});
			
			// Limpiar estado de arrastre
			isDragging = false;
			draggedTab = null;
			
			// Eliminar event listeners
			document.removeEventListener('mousemove', handleDragMove);
			document.removeEventListener('mouseup', handleDragEnd);
		}

		// Agregar event listener para iniciar arrastre
		tabContainer.querySelectorAll('.tab').forEach(tab => {
			tab.addEventListener('mousedown', handleDragStart);
		});
	},

	// Handlers centralizados para mensajes del backend
	messageHandlers: {
		updateActiveTab: (message) => TabManager.updateActiveTab(message.activeTabId),
		updateProblems: (message) => TabManager.updateDiagnosis(message.diagnostics),
		// Manejar ambos formatos para retrocompatibilidad
		updateDiagnosis: (message) => {
			console.log('[LoverTab | sidetabs.js] Recibida actualización de diagnósticos (comando updateDiagnosis):', message);
			if (message.updates && Array.isArray(message.updates)) {
				TabManager.updateDiagnosis(message.updates);
			} else if (message.diagnostics && Array.isArray(message.diagnostics)) {
				TabManager.updateDiagnosis(message.diagnostics);
			}
		},
		// Para retrocompatibilidad
		updateDiagnostics: (message) => {
			console.log('[LoverTab | sidetabs.js] Recibida actualización de diagnósticos (comando updateDiagnostics):', message);
			if (message.diagnostics && Array.isArray(message.diagnostics)) {
				TabManager.updateDiagnosis(message.diagnostics);
			} else if (message.updates && Array.isArray(message.updates)) {
				TabManager.updateDiagnosis(message.updates);
			}
		},
		updateTabsContent: (message) => {
			if (message.html) {
				tabContainer.innerHTML = message.html;
				TabManager.rebuildTabCache();
				EventHandler.setupDragDrop();
			}
		}
		// ...otros handlers
	}
};

//· Inicialización principal
function initialize() {
	console.log('[LoverTab | sidetabs.js] Iniciando aplicación...');
	const tabManagerReady = TabManager.initialize();
	if (!tabManagerReady) return;
	const eventHandlerReady = EventHandler.initialize();
	if (!eventHandlerReady) return;
	console.log('[LoverTab | sidetabs.js] Inicialización completada con éxito');
}

/// Ejecutar inicialización cuando el DOM esté listo
if (document.readyState === 'loading') {
	document.addEventListener('DOMContentLoaded', initialize);
} else {
	initialize();
}
